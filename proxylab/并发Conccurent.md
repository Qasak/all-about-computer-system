## 并发编程的问题

人类的思维倾向于循序渐进

时间的概念常常是误导人的

考虑计算机系统中所有可能的事件序列至少容易出错，而且常常是不可能的

+ 并发程序的经典问题：
  + 竞争：结果取决于系统中其他地方的任意调度决策
    + 谁得到飞机上最后一个座位？
  + 死锁：不正确的资源分配阻止了前进
    + 例如：交通堵塞
  + 活锁/饥饿/公平性：外部事件和/或系统调度决策可以阻止子任务的进度
    + 人们总是在你前面排队

## 迭代服务器

+ 迭代服务器一次处理一个请求

第二个客户端的请求阻塞在哪里？

![img](https://github.com/Qasak/all-about-computer-system/blob/master/proxylab/%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%98%BB%E5%A1%9E%E5%9C%A8read.png)

+ `connect`调用返回
  + 尽管连接上了，但并没有`accepted`
  + 服务端TCP管理器将请求排队
  + 这称作"TCP监听积压"特性
+ 调用`rio_written`返回
  + 服务端管理器缓存数据

+ 调用`rio_readlineb`阻塞
  + 服务端尚未写入(客户端)要读取的任何内容

## 并发服务器

### 进程

基于进程的服务器的issues

+ 侦听服务器进程必须获取僵尸子进程
  + 以避免致命的内存泄漏

+ 父进程必须关闭它的connfd副本
  + 内核为每个套接字/打开的文件保留引用计数
  + fork后，`refcnt（connfd）=2`
  + 连接只有`refcnt（connfd）=0`之后才会关闭

#### 基于进程的服务器的优缺点(pros and cons)

+同时处理多个连接

+清楚的模型

描述符（否）

文件表（是）

全局变量（否）

+简单明了

–过程控制的额外开销

–在进程之间共享数据非常重要

需要IPC（进程间通信）机制

FIFO（命名管道）、system v共享内存和信号量





### 事件

#### 基于事件的服务器的优缺点

+一个逻辑控制流和地址空间。

+可以用调试器单步执行。

+没有进程或线程控制开销。

>  高性能网络服务器和搜索引擎的设计选择。例如。Node.js nginx Tornado



–比基于进程或线程的设计复杂得多

–难以提供细粒度的并发性

+ E、 g.，如何处理部分HTTP请求

–无法利用多核

+ 单线程控制



### 线程

+ 传统视角

进程=进程上下文+(代码，数据，和栈)

代码，数据，和栈=栈+SP+共享库+brk+运行时堆+读/写数据+只读代码/数据

![img](https://github.com/Qasak/csapp-notes-and-labs/blob/master/proxylab/%E8%BF%9B%E7%A8%8B.png)

+ 另一个视角



进程上下文=程序上下文+内核上下文

+ 程序上下文=数据寄存器+状态码(condition code)+栈指针(SP)+程序技术器(PC)
+ 内核上下文=虚拟内存数据结构+描述符表+断点

线程上下文=进程上下文-内核上下文

进程=线程+(代码，数据和内核代码)

线程=栈+线程上下文

线程上下文=程序上下文

![img](https://github.com/Qasak/csapp-notes-and-labs/blob/master/proxylab/%E7%BA%BF%E7%A8%8B.png)

### 一个具有多线程的进程

多个线程可以与一个进程相关联

每个线程都有自己的逻辑控制流

每个线程共享相同的代码、数据和内核上下文

每个线程都有自己的局部变量堆栈

但不受其他线程的保护

每个线程都有自己的线程id（TID）

![img](https://github.com/Qasak/csapp-notes-and-labs/blob/master/proxylab/%E4%B8%80%E4%B8%AA%E5%85%B7%E6%9C%89%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%9B%E7%A8%8B.png)