# 同步：基础

Q: 线程化C程序中哪些变量是共享的？

A: 并不像“全局变量是共享的”和“栈变量是私有的”那么简单



定义：当且仅当多个线程引用变量x的某个实例时，才共享变量x。



需要回答以下问题：

+ 线程的内存模型是什么？

+ 变量的实例如何映射到内存？

+ 有多少线程可以引用这些实例？

## 线程内存模型

概念模型：

+ 多个线程在单个进程的上下文中运行

+ 每个线程都有自己独立的线程上下文
  + 线程ID、栈、栈指针、PC、条件码和GP(general-purpose)寄存器

+ 所有线程共享剩余的进程上下文
  + 进程虚拟地址空间的代码、数据、堆和共享库段
  + 打开文件和已安装的(信号)处理程序

在实际上，这一模式没有严格执行：

+ 寄存器值是真正独立和受保护的，但是…

+ 任何线程都可以读写任何其他线程的堆栈



**概念模型和操作模型之间的不匹配是混淆和错误的根源**



## 将变量实例映射到内存

全局变量

+ Def：在函数外部声明的变量

+ 虚拟内存只包含任何全局变量的一个实例



局部变量

+ Def：函数内部声明的变量，没有static属性

+ 每个线程栈包含每个局部变量的一个实例



局部静态变量

+ Def：在函数内部用static属性声明的变量

+ 虚拟内存只包含任何局部静态变量的一个实例。

### eg:badcnt

```asm
thread:
.LFB92:
	.cfi_startproc
	movq	(%rdi), %rcx
	testq	%rcx, %rcx
	jle	.L2
	movl	$0, %eax
.L3:
	movq	cnt(%rip), %rdx
	addq	$1, %rdx
	movq	%rdx, cnt(%rip)
	addq	$1, %rax
	cmpq	%rcx, %rax
	jne	.L3
.L2:
	movl	$0, %eax
	ret
	.cfi_endproc
```

![img](https://github.com/Qasak/csapp-notes-and-labs/blob/master/proxylab/badcnt-thread%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF.png)

### 并发执行

关键思想：一般来说，任何顺序一致的交织都是可能的，但有些会产生意想不到的结果！

+ $I_i$表示线程$i$执行指令$I$

+ $\%rdx_i$是线程$i$上下文中$\%rdx$的内容

![img](https://github.com/Qasak/csapp-notes-and-labs/blob/master/proxylab/thread%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F0.png)

![img](https://github.com/Qasak/csapp-notes-and-labs/blob/master/proxylab/thread%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F1.png)

