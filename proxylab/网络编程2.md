## Socket接口`socket`

+ 客户端和服务器使用`socket`函数创建*socket描述符*

  ```c
  int socket(int domain, int type, int protocol)
  
  /* AF_INET: Indicates that we are using 32-bit IPV4 addresses*/
  /* SOCK_STREAM: 这个socket是连接的一个端点 */
  int clientfd = Socket(AF_INET, SOCK_STREAM, 0);
  
  ```

  **协议特定！最佳实践是使用getaddrinfo自动生成参数，以便代码独立于协议**

socket返回的`clientfd`仅是部分打开的，还不能用于读写。

如何完成打开socket的工作，取决于我们是客户端还是服务器



## Socket接口`bind`

+ 服务器使用bind请求内核将服务器的套接字地址与套接字描述符相关联：

  ```c
  int bind(int sockfd, SA *addr, socklen_t addrlen);
  ```

> ` typedef struct sockaddr SA;`

+ 进程可以通过从描述符`sockfd`读取到达端点为`addr`的连接的字节。
+ 类似地，对`sockfd`的写入将沿着端点为`addr`的连接进行传输。

最佳实践是使用`getaddrinfo`来提供参数`addr`和`addrlen`

## Socket接口`listen`

+ 默认情况下，kernel假设socket函数中的描述符是一个*活动套接字*，它将位于连接的客户端

+ 服务器调用listen函数告诉内核描述符将由服务器而不是客户端使用：

  ```c
  int listen(int sockfd, int backlog);
  ```

+ 将`sockfd`从*活动套接字*转换为可以接受来自客户端的连接请求的*侦听套接字*。

+ `backlog`暗示内核在开始拒绝连接请求之前，队列中要排队的未完成的连接请求的数量。

  + 需要深入理解TCP/IP协议
  + 通常设置为一个较大的值，例如1024

## Socket接口`accept`

+ 服务器通过调用`accept`来等待来自客户端的连接请求：

  ```c
  int accept(int listenfd, SA *addr, int *addrlen);
  ```

+ 等待连接请求到达绑定到`listenfd`的连接，然后在`addr`中填写客户端的套接字地址，在`addrlen`中填写套接字地址的大小。

+ 返回可用于通过Unix I/O例程与客户端通信的*已连接描述符*。

## Socket接口`connect`

+ 客户端通过调用connect与服务器建立连接：

  ```c
  int connect(int clientfd, SA *addr, socklen_t addrlen);
  ```

+ 尝试在套接字地址`addr`处与服务器建立连接

  + 如果成功，那么`clientfd`现在就可以读写了。

  + 结果连接的特征是套接字对

    `(x:y, addr.sin_addr:addr.sin_port)`

  x是客户地址

  y是唯一标识客户端主机上的客户机进程的临时端口

最佳实践是使用`getaddrinfo`来提供参数`addr`和`addrlen`。

## `accept`图解

