## Socket接口`socket`

+ 客户端和服务器使用`socket`函数创建*socket描述符*

  ```c
  int socket(int domain, int type, int protocol)
  
  /* AF_INET: Indicates that we are using 32-bit IPV4 addresses*/
  /* SOCK_STREAM: 这个socket是连接的一个端点 */
  int clientfd = Socket(AF_INET, SOCK_STREAM, 0);
  
  ```

  **协议特定！最佳实践是使用getaddrinfo自动生成参数，以便代码独立于协议**

socket返回的`clientfd`仅是部分打开的，还不能用于读写。

如何完成打开socket的工作，取决于我们是客户端还是服务器



## Socket接口`bind`

+ 服务器使用bind请求内核将服务器的套接字地址与套接字描述符相关联：

  ```c
  int bind(int sockfd, SA *addr, socklen_t addrlen);
  ```

> ` typedef struct sockaddr SA;`

+ 进程可以通过从描述符`sockfd`读取到达端点为`addr`的连接的字节。
+ 类似地，对`sockfd`的写入将沿着端点为`addr`的连接进行传输。

最佳实践是使用`getaddrinfo`来提供参数`addr`和`addrlen`

## Socket接口`listen`

+ 默认情况下，kernel假设socket函数中的描述符是一个*活动套接字*，它将位于连接的客户端

+ 服务器调用listen函数告诉内核描述符将由服务器而不是客户端使用：

  ```c
  int listen(int sockfd, int backlog);
  ```

+ 将`sockfd`从*活动套接字*转换为可以接受来自客户端的连接请求的*侦听套接字*。

+ `backlog`暗示内核在开始拒绝连接请求之前，队列中要排队的未完成的连接请求的数量。

  + 需要深入理解TCP/IP协议
  + 通常设置为一个较大的值，例如1024

## Socket接口`accept`

+ 服务器通过调用`accept`来等待来自客户端的连接请求：

  ```c
  int accept(int listenfd, SA *addr, int *addrlen);
  ```

+ 等待连接请求到达绑定到`listenfd`的连接，然后在`addr`中填写客户端的套接字地址，在`addrlen`中填写套接字地址的大小。

+ 返回可用于通过Unix I/O例程与客户端通信的*已连接描述符*。

## Socket接口`connect`

+ 客户端通过调用connect与服务器建立连接：

  ```c
  int connect(int clientfd, SA *addr, socklen_t addrlen);
  ```

+ 尝试在套接字地址`addr`处与服务器建立连接

  + 如果成功，那么`clientfd`现在就可以读写了。

  + 结果连接的特征是套接字对

    `(x:y, addr.sin_addr:addr.sin_port)`

  x是客户地址

  y是唯一标识客户端主机上的客户机进程的临时端口

最佳实践是使用`getaddrinfo`来提供参数`addr`和`addrlen`。

## `accept`图解

## 连接描述符 vs. 监听描述符

+ 监听描述符

  客户端连接请求的终点

  创建一次并在服务器的生存期内存在

+ 连接描述符

  客户端和服务器之间连接的终点

  每次服务器接受来自客户机的连接请求时，都会创建一个新的描述符

  只有在服务客户机时才存在

+ 为什么有区别？

  允许并发服务器同时通过多个客户端连接进行通信

  e.g., 每次我们收到一个新的请求，我们都会fork一个子进程来处理这个请求

## Sockets辅助函数：`open_clientfd`

+ 和服务器建立连接

  ```c
  int open_clientfd(char *hostname, char *port) {
      int clientfd;
      struct addrinfo hints, *listp, *p;
  
      /* Get a list of potential server addresses */
      memset(&hints, 0, sizeof(struct addrinfo));
      hints.ai_socktype = SOCK_STREAM;  /* Open a connection */
      hints.ai_flags = AI_NUMERICSERV;  /* ... using a numeric port arg. */
      hints.ai_flags |= AI_ADDRCONFIG;  /* Recommended for connections */
      Getaddrinfo(hostname, port, &hints, &listp);
    
      /* Walk the list for one that we can successfully connect to */
      for (p = listp; p; p = p->ai_next) {
          /* Create a socket descriptor */
          if ((clientfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) < 0) 
              continue; /* Socket failed, try the next */
  
          /* Connect to the server */
          if (connect(clientfd, p->ai_addr, p->ai_addrlen) != -1) 
              break; /* Success */
          Close(clientfd); /* Connect failed, try another */  //line:netp:openclientfd:closefd
      } 
  
      /* Clean up */
      Freeaddrinfo(listp);
      if (!p) /* All connects failed */
          return -1;
      else    /* The last connect succeeded */
          return clientfd;
  }
  ```

  ## Echo客户端：主流程

  ```c
  #include "csapp.h"
  
  int main(int argc, char **argv) 
  {
      int clientfd;
      char *host, *port, buf[MAXLINE];
      rio_t rio;
  
      if (argc != 3) {
  	fprintf(stderr, "usage: %s <host> <port>\n", argv[0]);
  	exit(0);
      }
      host = argv[1];
      port = argv[2];
  
      clientfd = Open_clientfd(host, port);
      Rio_readinitb(&rio, clientfd);
  
      while (Fgets(buf, MAXLINE, stdin) != NULL) {
  	Rio_writen(clientfd, buf, strlen(buf));
  	Rio_readlineb(&rio, buf, MAXLINE);
  	Fputs(buf, stdout);
      }
      Close(clientfd); //line:netp:echoclient:close
      exit(0);
  }
  /* $end echoclientmain */
  
  ```

  ## 迭代Echo服务器：主流程

  ```c
  #include "csapp.h”
  void echo(int connfd);
  
  int main(int argc, char **argv)
  {
      int listenfd, connfd;
      socklen_t clientlen;
      struct sockaddr_storage clientaddr; /* Enough room for any addr */                                                                                                               
      char client_hostname[MAXLINE], client_port[MAXLINE];
  
      listenfd = Open_listenfd(argv[1]);
      while (1) {
  	clientlen = sizeof(struct sockaddr_storage); /* Important! */
  	connfd = Accept(listenfd, (SA *)&clientaddr, &clientlen);
  	Getnameinfo((SA *) &clientaddr, clientlen, 
                      client_hostname, MAXLINE, client_port, MAXLINE, 0);
  	printf("Connected to (%s, %s)\n", client_hostname, client_port);
  	echo(connfd);
  	Close(connfd);
      }
      exit(0);
  }
  ```

  ## Echo 服务器：`echo`函数

  + 服务器使用RIO读取和回显文本行，直到遇到EOF（文件结束）条件。

    客户端调用`close(clientfd)`造成EOF条件

```c
void echo(int connfd)
{
    size_t n;
    char buf[MAXLINE];
    rio_t rio;

    Rio_readinitb(&rio, connfd);
    while((n = Rio_readlineb(&rio, buf, MAXLINE)) != 0) { 
        printf("server received %d bytes\n", (int)n);
	Rio_writen(connfd, buf, n);
    }
}
```

## 测试服务器：`telnet`

+ telnet程序对于测试通过Internet连接传输ASCII字符串的服务器是极其有用的

  我们的简单回声服务器

  Web服务器

  邮件服务器