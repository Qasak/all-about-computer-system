## UNIX I/O

+ 文件到设备的优雅映射允许内核导出名为Unix I/O的简单接口：

  + 打开和关闭文件
    + `open（）和close（）`

  + 读写文件
    + `read（）和write（）`

  + 更改当前文件位置（seek）
    + 指示文件中要读或写的下一个偏移量
    + `lseek（）`

### 文件类型

+ 每个文件都有一个类型，指示其在系统中的角色

  常规文件：包含任意数据

  目录：相关文件组的索引

  套接字：用于与另一台计算机上的进程通信

+ 超出我们讨论范围的类型

  命名管道**named pipe**（aka FIFOs, for its behavior）

  符号链接

  字符和块设备

  > 在Linux中，设备类型可以分为：字符设备、块设备和网络设备。
  >
  > 1 字符设备
  >
  > 提供连续的数据流，应用程序可以顺序读取，通常不支持随机存取。相反，此类设备支持按字节/字符来读写数据。举例来说，键盘、串口、调制解调器都是典型的字符设备。
  >
  > 2 块设备
  >
  > 应用程序可以随机访问设备数据，程序可自行确定读取数据的位置。硬盘、软盘、CD-ROM驱动器和闪存都是典型的块设备，应用程序可以寻址磁盘上的任何位置，并由此读取数据。此外，数据的读写只能以块(通常是512B)的倍数进行。与字符设备不同，块设备并不支持基于字符的寻址。
  >
  > 作者：CodeMyLove
  > 链接：https://www.jianshu.com/p/477c5b583fbe

  

  > **符号链接**（**软链接、Symbolic link**）是一类特殊的[文件](https://zh.wikipedia.org/wiki/计算机文件)， 其包含有一条以绝对[路径](https://zh.wikipedia.org/wiki/路径_(计算机科学))或者相对路径的形式指向其它文件或者目录的引用。
  >
  > 一个符号链接文件仅包含有一个文本字符串，其被操作系统解释为一条指向另一个文件或者目录的路径
  >
  > ```
  > ln -s 目标 链接名称
  > ```
  >
  > **命名管道**可用于从一个进程向另一个进程发送信息而不需使用中间临时文件
  >
  > ```c
  > 
  > #include <sys/types.h>
  > #include <sys/stat.h>
  > /* 尽量使用mkfifo */
  > int mkfifo(const char *filename, mode_t mode);
  > int mknod(const char *filename, mode_t mode | S_IFIFO, (dev_t)0);
  > 
  > ```
  >
  > 打开fifo文件的四种方式
  >
  > ```c
  > 
  > open(const char *path, O_RDONLY);//1
  > open(const char *path, O_RDONLY | O_NONBLOCK);//2
  > open(const char *path, O_WRONLY);//3
  > open(const char *path, O_WRONLY | O_NONBLOCK);//4
  > 
  > ```
  >
  > 选项O_NONBLOCK表示非阻塞，加上这个选项后，表示open调用是非阻塞的，如果没有这个选项，则表示open调用是阻塞的。
  >
  > 对于以只读方式（O_RDONLY）打开的FIFO文件，如果open调用是阻塞的（即第二个参数为O_RDONLY），除非有一个进程以写方式打开同一个FIFO，否则它不会返回；如果open调用是非阻塞的的（即第二个参数为O_RDONLY | O_NONBLOCK），则即使没有其他进程以写方式打开同一个FIFO文件，open调用将成功并立即返回
  >
  > 
  >
  > **命名/匿名管道**
  >
  > 使用匿名管道，则通信的进程之间需要一个父子关系，通信的两个进程一定是由一个共同的祖先进程启动。但是匿名管道没有上面说到的数据交叉的问题。
  >
  > 与使用匿名管道相比，我们可以看到fifowrite.exe和fiforead.exe这两个进程是没有什么必然的联系的，如果硬要说他们具有某种联系，就只能说是它们都访问同一个FIFO文件。它解决了之前在匿名管道中出现的通信的两个进程一定是由一个共同的祖先进程启动的问题。但是为了数据的安全，我们很多时候要采用阻塞的FIFO，让写操作变成原子操作
  > 

### 常规文件

+ 常规文件包含任意数据
+ 应用程序通常区分文本文件和二进制文件
  + 文本文件是只有ASCII或Unicode字符的常规文件
  + 二进制文件就是一切其他文件
    + eg 对象文件，JPEG图像
  + 内核不知道区别

+ 文本文件是*文本行*的序列
  + 文本行是以换行符（'\n'）结尾的字符序列
    + 换行符为0xa，与ASCII换行符（LF）相同

+ 其他系统中的行终止（EOL）指示符

  + Linux和Mac OS:'\n'（0xa）
    + 换行（LF）

  + Windows和Internet协议：'\r\n'（0xd 0xa）
    + 回车（CR）后接换行（LF）



## RIO包



## 元数据，共享，重定向



## 标准I/O



